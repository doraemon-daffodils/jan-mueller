__NUXT_JSONP__("/de/projects/refunk", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak){return {data:[{project:{slug:Q,description:"Eine Bibliothek zum Studieren von primitiven rekursiven Funktionen mit Kotlin.",title:K,repository:Q,thumbnail:"refunk\u002Fthumbnail.webp",toc:[{id:R,depth:C,text:S},{id:T,depth:C,text:U},{id:V,depth:C,text:W},{id:X,depth:C,text:Y}],body:{type:"root",children:[{type:b,tag:q,props:{},children:[{type:b,tag:Z,props:{},children:[{type:b,tag:L,props:{},children:[{type:a,value:K}]}]},{type:a,value:" war mein erstes Kotlin-Projekt.\nEs handelt sich um eine Bibliothek zum Studieren und Auswerten primitiver rekursiver Funktionen, welche ich parallel zur Vorlesung "},{type:b,tag:L,props:{},children:[{type:a,value:"Theoretische Informatik: Berechenbarkeit und formale Sprachen"}]},{type:a,value:" der Universität Kassel entwickelt habe.\nInfolgedessen lehnt sie sich eng an die Syntax und Formalitäten dieses Kurses an und bietet eine ausdrucksstarke DSL."}]},{type:a,value:f},{type:b,tag:q,props:{},children:[{type:a,value:"Mein Projekt "},{type:b,tag:"nuxt-link",props:{to:_},children:[{type:b,tag:Z,props:{},children:[{type:b,tag:L,props:{},children:[{type:a,value:K}]},{type:a,value:" Playground"}]}]},{type:a,value:" bietet einen interaktiven Editor zum Verwenden dieser Bibliothek."}]},{type:a,value:f},{type:b,tag:D,props:{id:R},children:[{type:b,tag:E,props:{href:"#grundfunktionen",ariaHidden:F,tabIndex:G},children:[{type:b,tag:c,props:{className:[H,I]},children:[]}]},{type:a,value:S}]},{type:a,value:f},{type:b,tag:q,props:{},children:[{type:a,value:"Die gesamte Bibliothek, einschließlich jeder bereitgestellten Funktion, baut auf den drei Grundfunktionen auf:"}]},{type:a,value:f},{type:b,tag:"ul",props:{},children:[{type:a,value:f},{type:b,tag:M,props:{},children:[{type:b,tag:h,props:{},children:[{type:a,value:"constant(value)"}]},{type:a,value:$},{type:b,tag:h,props:{},children:[{type:a,value:"const(value)"}]},{type:a,value:$},{type:b,tag:h,props:{},children:[{type:a,value:"zero"}]},{type:a,value:J},{type:b,tag:h,props:{},children:[{type:a,value:"one"}]},{type:a,value:o}]},{type:a,value:f},{type:b,tag:M,props:{},children:[{type:b,tag:h,props:{},children:[{type:a,value:"Successor"}]},{type:a,value:J},{type:b,tag:h,props:{},children:[{type:a,value:"successor"}]},{type:a,value:o}]},{type:a,value:f},{type:b,tag:M,props:{},children:[{type:b,tag:h,props:{},children:[{type:a,value:"projection(index)"}]},{type:a,value:J},{type:b,tag:h,props:{},children:[{type:a,value:N}]},{type:a,value:" bis "},{type:b,tag:h,props:{},children:[{type:a,value:"tenth"}]},{type:a,value:o}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:D,props:{id:T},children:[{type:b,tag:E,props:{href:"#komposition",ariaHidden:F,tabIndex:G},children:[{type:b,tag:c,props:{className:[H,I]},children:[]}]},{type:a,value:U}]},{type:a,value:f},{type:b,tag:q,props:{},children:[{type:a,value:"Die Funktionskomposition wird durch die Klasse "},{type:b,tag:h,props:{},children:[{type:a,value:"Composition"}]},{type:a,value:" und verschiedene Wrapper-Methoden gehandhabt."}]},{type:a,value:f},{type:b,tag:t,props:{className:[u]},children:[{type:b,tag:v,props:{className:[w,x]},children:[{type:b,tag:h,props:{},children:[{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:ab},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:ac},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:ab},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:ad},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:ae},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:" f of "},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:ac},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:af}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:af}]},{type:a,value:ad},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:B}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:" myAltComp "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:ag}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:a,value:"g1"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:y}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:y}]},{type:a,value:" gn"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:q,props:{},children:[{type:a,value:"Das folgende Beispiel demonstriert eine einfache Komposition unter Verwendung der, in diesem Fall optionalen, Projektionen "},{type:b,tag:h,props:{},children:[{type:a,value:N}]},{type:a,value:J},{type:b,tag:h,props:{},children:[{type:a,value:"second"}]},{type:a,value:o}]},{type:a,value:f},{type:b,tag:t,props:{className:[u]},children:[{type:b,tag:v,props:{className:[w,x]},children:[{type:b,tag:h,props:{},children:[{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:"\u002F\u002F f(x, y) = 2 * (x + y)"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:"multiplication"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:"const"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"2"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:y}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:"addition"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:a,value:N},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:y}]},{type:a,value:" second"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:"\u002F\u002F `addition(first, second)` ist äquivalent zu `addition`"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:" result "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:ag}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"10"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:y}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"11"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:"\u002F\u002F = 42"}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:q,props:{},children:[{type:a,value:"Unäre Funktionen können auch mit "},{type:b,tag:h,props:{},children:[{type:a,value:"Function::andThen"}]},{type:a,value:" zusammengesetzt werden."}]},{type:a,value:f},{type:b,tag:t,props:{className:[u]},children:[{type:b,tag:v,props:{className:[w,x]},children:[{type:b,tag:h,props:{},children:[{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:ae},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:" myFunction andThen myUnaryFunction\n"}]}]}]},{type:a,value:f},{type:b,tag:D,props:{id:V},children:[{type:b,tag:E,props:{href:"#rekursion",ariaHidden:F,tabIndex:G},children:[{type:b,tag:c,props:{className:[H,I]},children:[]}]},{type:a,value:W}]},{type:a,value:f},{type:b,tag:q,props:{},children:[{type:a,value:"Rekursionen können mit mehreren Erweiterungsmethoden definiert werden."}]},{type:a,value:f},{type:b,tag:t,props:{className:[u]},children:[{type:b,tag:v,props:{className:[w,x]},children:[{type:b,tag:h,props:{},children:[{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:" myRecursion "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:"recursive"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:a,value:"myRecursiveCaseFunction"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:" withBaseCase myBaseCaseFunction                \n"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:"             "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:O},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:" \n                        aFunction of anotherFunction \n                  "},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:B}]},{type:a,value:" withBaseCase "},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:" \n                        someFunction andThen someOtherFunction \n                  "},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:B}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:q,props:{},children:[{type:a,value:"Benannte Projektionen helfen beim Zugriff auf die Rekursionsergebnisse, -parameter und -argumente."}]},{type:a,value:f},{type:b,tag:t,props:{className:[u]},children:[{type:b,tag:v,props:{className:[w,x]},children:[{type:b,tag:h,props:{},children:[{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:" addition "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:O},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:" successor of recursionResult "},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:B}]},{type:a,value:" withBaseCase firstBaseCaseArgument\n"},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:" predecessor "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:O},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:" recursionParameter "},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:B}]},{type:a,value:" withBaseCase zero\n"}]}]}]},{type:a,value:f},{type:b,tag:D,props:{id:X},children:[{type:b,tag:E,props:{href:"#funktionsinvokation",ariaHidden:F,tabIndex:G},children:[{type:b,tag:c,props:{className:[H,I]},children:[]}]},{type:a,value:Y}]},{type:a,value:f},{type:b,tag:q,props:{},children:[{type:a,value:"Der Operator "},{type:b,tag:h,props:{},children:[{type:a,value:"Function::invoke"}]},{type:a,value:" wertet Funktionen für angegebene Argumente aus."}]},{type:a,value:f},{type:b,tag:t,props:{className:[u]},children:[{type:b,tag:v,props:{className:[w,x]},children:[{type:b,tag:h,props:{},children:[{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:" addTwo "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:" successor andThen successor\n"},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:P}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:ah}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"0"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:"\u002F\u002F Gibt 2 aus"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:P}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:ah}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:ai}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:aj}]},{type:a,value:"\n\n"},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:" myFunction "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:" predecessor of addition\n"},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:P}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:"myFunction"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"3"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:y}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:ai}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:aj}]},{type:a,value:f}]}]}]}]},dir:"\u002Fde\u002Fprojects",path:"\u002Fde\u002Fprojects\u002Frefunk",extension:".md",createdAt:ak,updatedAt:ak,readingTime:"2 min read",bodyText:"\u003Cp\u003E\u003Cstrong\u003E\u003Cem\u003EREFUNK\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E war mein erstes Kotlin-Projekt.\nEs handelt sich um eine Bibliothek zum Studieren und Auswerten primitiver rekursiver Funktionen, welche ich parallel zur Vorlesung \u003Cem\u003ETheoretische Informatik: Berechenbarkeit und formale Sprachen\u003C\u002Fem\u003E der Universität Kassel entwickelt habe.\nInfolgedessen lehnt sie sich eng an die Syntax und Formalitäten dieses Kurses an und bietet eine ausdrucksstarke DSL.\u003C\u002Fp\u003E\n\u003Cp\u003EMein Projekt \u003Ca href=\"\u002Fde\u002Fprojects\u002Frefunk-playground\"\u003E\u003Cstrong\u003E\u003Cem\u003EREFUNK\u003C\u002Fem\u003E Playground\u003C\u002Fstrong\u003E\u003C\u002Fa\u003E bietet einen interaktiven Editor zum Verwenden dieser Bibliothek.\u003C\u002Fp\u003E\n\u003Ch2\u003EGrundfunktionen\u003C\u002Fh2\u003E\n\u003Cp\u003EDie gesamte Bibliothek, einschließlich jeder bereitgestellten Funktion, baut auf den drei Grundfunktionen auf:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Econstant(value)\u003C\u002Fcode\u003E, \u003Ccode\u003Econst(value)\u003C\u002Fcode\u003E, \u003Ccode\u003Ezero\u003C\u002Fcode\u003E und \u003Ccode\u003Eone\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003ESuccessor\u003C\u002Fcode\u003E und \u003Ccode\u003Esuccessor\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eprojection(index)\u003C\u002Fcode\u003E und \u003Ccode\u003Efirst\u003C\u002Fcode\u003E bis \u003Ccode\u003Etenth\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2\u003EKomposition\u003C\u002Fh2\u003E\n\u003Cp\u003EDie Funktionskomposition wird durch die Klasse \u003Ccode\u003EComposition\u003C\u002Fcode\u003E und verschiedene Wrapper-Methoden gehandhabt.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-kotlin\"\u003Eval f = ... \nval g1 = ... \n...\nval gn = ...\nval myComposition = f of { g1 and ... and gn }\nval myAltComp = f(g1, ..., gn)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EDas folgende Beispiel demonstriert eine einfache Komposition unter Verwendung der, in diesem Fall optionalen, Projektionen \u003Ccode\u003Efirst\u003C\u002Fcode\u003E und \u003Ccode\u003Esecond\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-kotlin\"\u003E\u002F\u002F f(x, y) = 2 * (x + y)\nval f = multiplication(const(2), addition(first, second)) \u002F\u002F `addition(first, second)` ist äquivalent zu `addition`\nval result = f(10, 11) \u002F\u002F = 42\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EUnäre Funktionen können auch mit \u003Ccode\u003EFunction::andThen\u003C\u002Fcode\u003E zusammengesetzt werden.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-kotlin\"\u003Eval myComposition = myFunction andThen myUnaryFunction\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2\u003ERekursion\u003C\u002Fh2\u003E\n\u003Cp\u003ERekursionen können mit mehreren Erweiterungsmethoden definiert werden.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-kotlin\"\u003Eval myRecursion = recursive(myRecursiveCaseFunction) withBaseCase myBaseCaseFunction                \n...             = recursive { \n                        aFunction of anotherFunction \n                  } withBaseCase { \n                        someFunction andThen someOtherFunction \n                  }\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EBenannte Projektionen helfen beim Zugriff auf die Rekursionsergebnisse, -parameter und -argumente.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-kotlin\"\u003Eval addition = recursive { successor of recursionResult } withBaseCase firstBaseCaseArgument\nval predecessor = recursive { recursionParameter } withBaseCase zero\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2\u003EFunktionsinvokation\u003C\u002Fh2\u003E\n\u003Cp\u003EDer Operator \u003Ccode\u003EFunction::invoke\u003C\u002Fcode\u003E wertet Funktionen für angegebene Argumente aus.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-kotlin\"\u003Eval addTwo = successor andThen successor\nprintln(addTwo(0)) \u002F\u002F Gibt 2 aus\nprintln(addTwo(40)) \u002F\u002F Gibt 42 aus\n\nval myFunction = predecessor of addition\nprintln(myFunction(3, 40)) \u002F\u002F Gibt 42 aus\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n"},prev:{slug:"graph-editor",title:"Graph Editor",path:"\u002Fde\u002Fprojects\u002Fgraph-editor"},next:{slug:"refunk-playground",title:"REFUNK Playground",path:_}}],fetch:{},mutations:[]}}("text","element","span","token","punctuation","\n","operator","code"," ","keyword","=","val","(",")",".","function","p","..","number","div","nuxt-content-highlight","pre","language-kotlin","line-numbers",",","comment","{","}",2,"h2","a","true",-1,"icon","icon-link"," und ","REFUNK","em","li","first"," recursive ","println","refunk","grundfunktionen","Grundfunktionen","komposition","Komposition","rekursion","Rekursion","funktionsinvokation","Funktionsinvokation","strong","\u002Fde\u002Fprojects\u002Frefunk-playground",", "," f "," \n"," g1 "," gn "," myComposition ","and","f","addTwo","40","\u002F\u002F Gibt 42 aus","2021-06-06T22:12:52.694Z")));