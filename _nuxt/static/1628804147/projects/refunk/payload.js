__NUXT_JSONP__("/projects/refunk", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,_,$,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak){return {data:[{project:{slug:R,description:"A library for studying primitive recursive functions with Kotlin.",title:K,repository:R,thumbnail:"refunk\u002Fthumbnail.webp",toc:[{id:S,depth:C,text:T},{id:U,depth:C,text:L},{id:V,depth:C,text:W},{id:X,depth:C,text:Y}],body:{type:"root",children:[{type:b,tag:q,props:{},children:[{type:b,tag:Z,props:{},children:[{type:b,tag:M,props:{},children:[{type:a,value:K}]}]},{type:a,value:" was my first Kotlin project.\nIt's a library for studying and evaluating primitive recursive functions which I developed in parallel to the University of Kassel's course "},{type:b,tag:M,props:{},children:[{type:a,value:"Theoretical computer science: Computability and formal languages"}]},{type:a,value:".\nThus, it follows closely the syntax and formalities of that course and provides an expressive DSL."}]},{type:a,value:f},{type:b,tag:q,props:{},children:[{type:a,value:"My project "},{type:b,tag:"nuxt-link",props:{to:_},children:[{type:b,tag:Z,props:{},children:[{type:b,tag:M,props:{},children:[{type:a,value:K}]},{type:a,value:" Playground"}]}]},{type:a,value:" provides an interactive editor for this library."}]},{type:a,value:f},{type:b,tag:D,props:{id:S},children:[{type:b,tag:E,props:{href:"#basic-functions",ariaHidden:F,tabIndex:G},children:[{type:b,tag:c,props:{className:[H,I]},children:[]}]},{type:a,value:T}]},{type:a,value:f},{type:b,tag:q,props:{},children:[{type:a,value:"The entire library, including every provided function, builds on the three basic functions:"}]},{type:a,value:f},{type:b,tag:"ul",props:{},children:[{type:a,value:f},{type:b,tag:N,props:{},children:[{type:b,tag:h,props:{},children:[{type:a,value:"constant(value)"}]},{type:a,value:$},{type:b,tag:h,props:{},children:[{type:a,value:"const(value)"}]},{type:a,value:$},{type:b,tag:h,props:{},children:[{type:a,value:"zero"}]},{type:a,value:J},{type:b,tag:h,props:{},children:[{type:a,value:"one"}]},{type:a,value:o}]},{type:a,value:f},{type:b,tag:N,props:{},children:[{type:b,tag:h,props:{},children:[{type:a,value:"Successor"}]},{type:a,value:J},{type:b,tag:h,props:{},children:[{type:a,value:"successor"}]},{type:a,value:o}]},{type:a,value:f},{type:b,tag:N,props:{},children:[{type:b,tag:h,props:{},children:[{type:a,value:"projection(index)"}]},{type:a,value:J},{type:b,tag:h,props:{},children:[{type:a,value:O}]},{type:a,value:" to "},{type:b,tag:h,props:{},children:[{type:a,value:"tenth"}]},{type:a,value:o}]},{type:a,value:f}]},{type:a,value:f},{type:b,tag:D,props:{id:U},children:[{type:b,tag:E,props:{href:"#composition",ariaHidden:F,tabIndex:G},children:[{type:b,tag:c,props:{className:[H,I]},children:[]}]},{type:a,value:L}]},{type:a,value:f},{type:b,tag:q,props:{},children:[{type:a,value:"Function composition is handled by the "},{type:b,tag:h,props:{},children:[{type:a,value:L}]},{type:a,value:" class and various wrapper methods."}]},{type:a,value:f},{type:b,tag:t,props:{className:[u]},children:[{type:b,tag:v,props:{className:[w,x]},children:[{type:b,tag:h,props:{},children:[{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:ab},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:ac},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:ab},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:ad},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:ae},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:" f of "},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:ac},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:af}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:af}]},{type:a,value:ad},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:B}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:" myAltComp "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:ag}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:a,value:"g1"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:y}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:y}]},{type:a,value:" gn"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:q,props:{},children:[{type:a,value:"The following example demonstrates simple composition using the, in this case optional, projections "},{type:b,tag:h,props:{},children:[{type:a,value:O}]},{type:a,value:J},{type:b,tag:h,props:{},children:[{type:a,value:"second"}]},{type:a,value:o}]},{type:a,value:f},{type:b,tag:t,props:{className:[u]},children:[{type:b,tag:v,props:{className:[w,x]},children:[{type:b,tag:h,props:{},children:[{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:"\u002F\u002F f(x, y) = 2 * (x + y)"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:aa},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:"multiplication"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:"const"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"2"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:y}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:"addition"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:a,value:O},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:y}]},{type:a,value:" second"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:"\u002F\u002F `addition(first, second)` is equal to `addition`"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:" result "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:ag}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"10"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:y}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"11"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:"\u002F\u002F = 42"}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:q,props:{},children:[{type:a,value:"Unary functions can also be composed with "},{type:b,tag:h,props:{},children:[{type:a,value:"Function::andThen"}]}]},{type:a,value:f},{type:b,tag:t,props:{className:[u]},children:[{type:b,tag:v,props:{className:[w,x]},children:[{type:b,tag:h,props:{},children:[{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:ae},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:" myFunction andThen myUnaryFunction\n"}]}]}]},{type:a,value:f},{type:b,tag:D,props:{id:V},children:[{type:b,tag:E,props:{href:"#recursion",ariaHidden:F,tabIndex:G},children:[{type:b,tag:c,props:{className:[H,I]},children:[]}]},{type:a,value:W}]},{type:a,value:f},{type:b,tag:q,props:{},children:[{type:a,value:"Recursions can be defined using multiple extension methods."}]},{type:a,value:f},{type:b,tag:t,props:{className:[u]},children:[{type:b,tag:v,props:{className:[w,x]},children:[{type:b,tag:h,props:{},children:[{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:" myRecursion "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:"recursive"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:a,value:"myRecursiveCaseFunction"},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:" withBaseCase myBaseCaseFunction                \n"},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:r}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:o}]},{type:a,value:"             "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:" \n                        aFunction of anotherFunction \n                  "},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:B}]},{type:a,value:" withBaseCase "},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:" \n                        someFunction andThen someOtherFunction \n                  "},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:B}]},{type:a,value:f}]}]}]},{type:a,value:f},{type:b,tag:q,props:{},children:[{type:a,value:"Named projections help access the recursion results, parameters and arguments."}]},{type:a,value:f},{type:b,tag:t,props:{className:[u]},children:[{type:b,tag:v,props:{className:[w,x]},children:[{type:b,tag:h,props:{},children:[{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:" addition "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:" successor of recursionResult "},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:B}]},{type:a,value:" withBaseCase firstBaseCaseArgument\n"},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:" predecessor "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:P},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:A}]},{type:a,value:" recursionParameter "},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:B}]},{type:a,value:" withBaseCase zero\n"}]}]}]},{type:a,value:f},{type:b,tag:D,props:{id:X},children:[{type:b,tag:E,props:{href:"#invocation",ariaHidden:F,tabIndex:G},children:[{type:b,tag:c,props:{className:[H,I]},children:[]}]},{type:a,value:Y}]},{type:a,value:f},{type:b,tag:q,props:{},children:[{type:a,value:"The operator "},{type:b,tag:h,props:{},children:[{type:a,value:"Function::invoke"}]},{type:a,value:" evaluates a function for the given arguments."}]},{type:a,value:f},{type:b,tag:t,props:{className:[u]},children:[{type:b,tag:v,props:{className:[w,x]},children:[{type:b,tag:h,props:{},children:[{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:" addTwo "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:" successor andThen successor\n"},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:Q}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:ah}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"0"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:"\u002F\u002F Prints 2"}]},{type:a,value:f},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:Q}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:ah}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:ai}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:aj}]},{type:a,value:"\n\n"},{type:b,tag:c,props:{className:[d,j]},children:[{type:a,value:l}]},{type:a,value:" myFunction "},{type:b,tag:c,props:{className:[d,g]},children:[{type:a,value:k}]},{type:a,value:" predecessor of addition\n"},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:Q}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[d,p]},children:[{type:a,value:"myFunction"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:m}]},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:"3"}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:y}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,s]},children:[{type:a,value:ai}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:b,tag:c,props:{className:[d,e]},children:[{type:a,value:n}]},{type:a,value:i},{type:b,tag:c,props:{className:[d,z]},children:[{type:a,value:aj}]},{type:a,value:f}]}]}]}]},dir:"\u002Fen\u002Fprojects",path:"\u002Fen\u002Fprojects\u002Frefunk",extension:".md",createdAt:ak,updatedAt:ak,readingTime:"2 min read",bodyText:"\u003Cp\u003E\u003Cstrong\u003E\u003Cem\u003EREFUNK\u003C\u002Fem\u003E\u003C\u002Fstrong\u003E was my first Kotlin project.\nIt's a library for studying and evaluating primitive recursive functions which I developed in parallel to the University of Kassel's course \u003Cem\u003ETheoretical computer science: Computability and formal languages\u003C\u002Fem\u003E.\nThus, it follows closely the syntax and formalities of that course and provides an expressive DSL.\u003C\u002Fp\u003E\n\u003Cp\u003EMy project \u003Ca href=\"\u002Fprojects\u002Frefunk-playground\"\u003E\u003Cstrong\u003E\u003Cem\u003EREFUNK\u003C\u002Fem\u003E Playground\u003C\u002Fstrong\u003E\u003C\u002Fa\u003E provides an interactive editor for this library.\u003C\u002Fp\u003E\n\u003Ch2\u003EBasic functions\u003C\u002Fh2\u003E\n\u003Cp\u003EThe entire library, including every provided function, builds on the three basic functions:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Ccode\u003Econstant(value)\u003C\u002Fcode\u003E, \u003Ccode\u003Econst(value)\u003C\u002Fcode\u003E, \u003Ccode\u003Ezero\u003C\u002Fcode\u003E and \u003Ccode\u003Eone\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003ESuccessor\u003C\u002Fcode\u003E and \u003Ccode\u003Esuccessor\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eprojection(index)\u003C\u002Fcode\u003E and \u003Ccode\u003Efirst\u003C\u002Fcode\u003E to \u003Ccode\u003Etenth\u003C\u002Fcode\u003E.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2\u003EComposition\u003C\u002Fh2\u003E\n\u003Cp\u003EFunction composition is handled by the \u003Ccode\u003EComposition\u003C\u002Fcode\u003E class and various wrapper methods.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-kotlin\"\u003Eval f = ... \nval g1 = ... \n...\nval gn = ...\nval myComposition = f of { g1 and ... and gn }\nval myAltComp = f(g1, ..., gn)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EThe following example demonstrates simple composition using the, in this case optional, projections \u003Ccode\u003Efirst\u003C\u002Fcode\u003E and \u003Ccode\u003Esecond\u003C\u002Fcode\u003E.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-kotlin\"\u003E\u002F\u002F f(x, y) = 2 * (x + y)\nval f = multiplication(const(2), addition(first, second)) \u002F\u002F `addition(first, second)` is equal to `addition`\nval result = f(10, 11) \u002F\u002F = 42\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EUnary functions can also be composed with \u003Ccode\u003EFunction::andThen\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-kotlin\"\u003Eval myComposition = myFunction andThen myUnaryFunction\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2\u003ERecursion\u003C\u002Fh2\u003E\n\u003Cp\u003ERecursions can be defined using multiple extension methods.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-kotlin\"\u003Eval myRecursion = recursive(myRecursiveCaseFunction) withBaseCase myBaseCaseFunction                \n...             = recursive { \n                        aFunction of anotherFunction \n                  } withBaseCase { \n                        someFunction andThen someOtherFunction \n                  }\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003ENamed projections help access the recursion results, parameters and arguments.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-kotlin\"\u003Eval addition = recursive { successor of recursionResult } withBaseCase firstBaseCaseArgument\nval predecessor = recursive { recursionParameter } withBaseCase zero\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2\u003EInvocation\u003C\u002Fh2\u003E\n\u003Cp\u003EThe operator \u003Ccode\u003EFunction::invoke\u003C\u002Fcode\u003E evaluates a function for the given arguments.\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-kotlin\"\u003Eval addTwo = successor andThen successor\nprintln(addTwo(0)) \u002F\u002F Prints 2\nprintln(addTwo(40)) \u002F\u002F Prints 42\n\nval myFunction = predecessor of addition\nprintln(myFunction(3, 40)) \u002F\u002F Prints 42\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n"},prev:{slug:"koffee",title:"Koffee",path:"\u002Fprojects\u002Fkoffee"},next:{slug:"refunk-playground",title:"REFUNK Playground",path:_}}],fetch:{},mutations:[]}}("text","element","span","token","punctuation","\n","operator","code"," ","keyword","=","val","(",")",".","function","p","..","number","div","nuxt-content-highlight","pre","language-kotlin","line-numbers",",","comment","{","}",2,"h2","a","true",-1,"icon","icon-link"," and ","REFUNK","Composition","em","li","first"," recursive ","println","refunk","basic-functions","Basic functions","composition","recursion","Recursion","invocation","Invocation","strong","\u002Fprojects\u002Frefunk-playground",", "," f "," \n"," g1 "," gn "," myComposition ","and","f","addTwo","40","\u002F\u002F Prints 42","2021-08-12T21:34:58.162Z")));